#ifndef CLASSICPROTOCOL_H_
#define CLASSICPROTOCOL_H_

#include "IProtocol.hpp"
#include "Packet.hpp"
#include "../Utils/MCString.hpp"

#include <map>
#include <memory>

// FIXME: only used for htonl?
#ifdef __linux__
#include <arpa/inet.h>
#elif _WIN32
#define NOMINMAX // bug with winsock redefining min
#include <winsock2.h>
#undef NOMINMAX
#endif

namespace Net {
class Client;

class ClassicProtocol final : public IProtocol {
public:
	static const uint8_t kVersion = 0x07;

	enum BlockType {
		kAir,
		kStone,
		kGrass,
		kDirt,
		kCobblestone,
		kWoodPlanks,
		kSapling,
		kBedrock,
		kFlowingWater,
		kStationaryWater,
		kFlowingLava,
		kStationaryLava,
		kSand,
		kGravel,
		kGoldOre,
		kIronOre,
		kCoalOre,
		kWood,
		kLeaves,
		kSponge,
		kGlass,
		kRedCloth,
		kOrangeCloth,
		kYellowCloth,
		kLimeCloth,
		kGreenCloth,
		kAquaGreenCloth,
		kCyanCloth,
		kBlueCloth,
		kPurpleCloth,
		kIndigoCloth,
		kVioletCloth,
		kMagentaCloth,
		kPinkCloth,
		kBlackCloth,
		kGrayCloth,
		kWhiteCloth,
		kDandelion,
		kRose,
		kBrownMushroom,
		kRedMushroom,
		kGoldBlock,
		kIronBlock,
		kDoubleSlab,
		kSlab,
		kBricks,
		kTNT,
		kBookshelf,
		kMossStone,
		kObsidian
	};

	static std::map<uint8_t, std::string> blockTypes;

	virtual bool IsValidBlock(uint8_t type) const override
	{
		auto iter = blockTypes.find(type);
		if (iter != blockTypes.end())
			return true;
		return false;
	}

	virtual std::string GetBlockNameByType(uint8_t type) const override
	{
		std::string name;
		auto iter = blockTypes.find(type);
		if (iter != blockTypes.end())
			name = iter->second;
		return name;
	}

	/* BEGIN AUTOGENERATED CODE SECTION */
	enum Opcodes {
		kAuthentication = 0x0,
		kSetBlock = 0x05,
		kPositionOrientation = 0x08,
		kOrientation = 0x0b,
		kDespawn = 0x0c,
		kMessage = 0x0d,
		kServerIdentification = 0x0,
		kLevelInitialize = 0x02,
		kLevelDataChunk = 0x03,
		kLevelFinalize = 0x04,
		kSetBlock2 = 0x06,
		kSpawnPlayer = 0x07,
		kUserType = 0x0f,
		kDisconnectPlayer = 0x0e
	};

	static const uint32_t kAuthenticationSize = 131;
	static const uint32_t kSetBlockSize = 9;
	static const uint32_t kPositionOrientationSize = 10;
	static const uint32_t kOrientationSize = 4;
	static const uint32_t kDespawnSize = 2;
	static const uint32_t kMessageSize = 66;
	static const uint32_t kServerIdentificationSize = 131;
	static const uint32_t kLevelInitializeSize = 1;
	static const uint32_t kLevelDataChunkSize = 1028;
	static const uint32_t kLevelFinalizeSize = 7;
	static const uint32_t kSetBlock2Size = 8;
	static const uint32_t kSpawnPlayerSize = 74;
	static const uint32_t kUserTypeSize = 2;
	static const uint32_t kDisconnectPlayerSize = 65;

	// Client -> Server
	class AuthenticationPacket final : public Packet {
	public:
		uint8_t version;
		Utils::MCString name;
		Utils::MCString key;
		uint8_t UNK0;

		AuthenticationPacket() : AuthenticationPacket(0, std::string(), std::string(), 0) {}
		AuthenticationPacket(uint8_t version, Utils::MCString name, Utils::MCString key, uint8_t UNK0) :
			Packet(Opcodes::kAuthentication, kAuthenticationSize),
			version(version),
			name(name),
			key(key),
			UNK0(UNK0)
		{}

		virtual void Deserialize(Utils::BufferStream& reader) override
		{
			// Skip opcode because each packet knows its opcode
			reader.Skip(sizeof(m_opcode));

			reader.ReadUInt8(version);
			reader.ReadMCString(name);
			reader.ReadMCString(key);
			reader.ReadUInt8(UNK0);
		}

		virtual std::unique_ptr<Utils::BufferStream> Serialize() override
		{
			return nullptr;
		}
	};

	// Server <-> Client
	class SetBlockPacket final : public Packet {
	public:
		int16_t x;
		int16_t y;
		int16_t z;
		uint8_t mode;
		uint8_t type;

		SetBlockPacket() : SetBlockPacket(0, 0, 0, 0, 0) {}
		SetBlockPacket(int16_t x, int16_t y, int16_t z, uint8_t mode, uint8_t type) :
			Packet(Opcodes::kSetBlock, kSetBlockSize),
			x(x),
			y(y),
			z(z),
			mode(mode),
			type(type)
		{}

		virtual void Deserialize(Utils::BufferStream& reader) override
		{
			// Skip opcode because each packet knows its opcode
			reader.Skip(sizeof(m_opcode));

			reader.ReadInt16(x);
			reader.ReadInt16(y);
			reader.ReadInt16(z);
			reader.ReadUInt8(mode);
			reader.ReadUInt8(type);

			x = ntohs(x);
			y = ntohs(y);
			z = ntohs(z);
		}

		virtual std::unique_ptr<Utils::BufferStream> Serialize() override
		{
			auto writer = std::make_unique<Utils::BufferStream>(m_packetSize);

			if (writer != nullptr) {
				writer->WriteUInt8(m_opcode);
				writer->WriteInt16(htons(x));
				writer->WriteInt16(htons(y));
				writer->WriteInt16(htons(z));
				writer->WriteUInt8(mode);
				writer->WriteUInt8(type);
			}

			return std::move(writer);
		}
	};

	// Server <-> Client
	class PositionOrientationPacket final : public Packet {
	public:
		int8_t pid;
		int16_t x;
		int16_t y;
		int16_t z;
		uint8_t yaw;
		uint8_t pitch;

		PositionOrientationPacket() : PositionOrientationPacket(0, 0, 0, 0, 0, 0) {}
		PositionOrientationPacket(int8_t pid, int16_t x, int16_t y, int16_t z, uint8_t yaw, uint8_t pitch) :
			Packet(Opcodes::kPositionOrientation, kPositionOrientationSize),
			pid(pid),
			x(x),
			y(y),
			z(z),
			yaw(yaw),
			pitch(pitch)
		{}

		virtual void Deserialize(Utils::BufferStream& reader) override
		{
			// Skip opcode because each packet knows its opcode
			reader.Skip(sizeof(m_opcode));

			reader.ReadInt8(pid);
			reader.ReadInt16(x);
			reader.ReadInt16(y);
			reader.ReadInt16(z);
			reader.ReadUInt8(yaw);
			reader.ReadUInt8(pitch);

			x = ntohs(x);
			y = ntohs(y);
			z = ntohs(z);
		}

		virtual std::unique_ptr<Utils::BufferStream> Serialize() override
		{
			auto writer = std::make_unique<Utils::BufferStream>(m_packetSize);

			if (writer != nullptr) {
				writer->WriteUInt8(m_opcode);
				writer->WriteInt8(pid);
				writer->WriteInt16(htons(x));
				writer->WriteInt16(htons(y));
				writer->WriteInt16(htons(z));
				writer->WriteUInt8(yaw);
				writer->WriteUInt8(pitch);
			}

			return std::move(writer);
		}
	};

	// Server -> Client
	class OrientationPacket final : public Packet {
	public:
		int8_t pid;
		uint8_t yaw;
		uint8_t pitch;

		OrientationPacket() : OrientationPacket(0, 0, 0) {}
		OrientationPacket(int8_t pid, uint8_t yaw, uint8_t pitch) :
			Packet(Opcodes::kOrientation, kOrientationSize),
			pid(pid),
			yaw(yaw),
			pitch(pitch)
		{}

		virtual void Deserialize(Utils::BufferStream& reader) override
		{
		}

		virtual std::unique_ptr<Utils::BufferStream> Serialize() override
		{
			auto writer = std::make_unique<Utils::BufferStream>(m_packetSize);

			if (writer != nullptr) {
				writer->WriteUInt8(m_opcode);
				writer->WriteInt8(pid);
				writer->WriteUInt8(yaw);
				writer->WriteUInt8(pitch);
			}

			return std::move(writer);
		}
	};

	// Server -> Client
	class DespawnPacket final : public Packet {
	public:
		int8_t pid;

		DespawnPacket() : DespawnPacket(0) {}
		DespawnPacket(int8_t pid) :
			Packet(Opcodes::kDespawn, kDespawnSize),
			pid(pid)
		{}

		virtual void Deserialize(Utils::BufferStream& reader) override
		{
		}

		virtual std::unique_ptr<Utils::BufferStream> Serialize() override
		{
			auto writer = std::make_unique<Utils::BufferStream>(m_packetSize);

			if (writer != nullptr) {
				writer->WriteUInt8(m_opcode);
				writer->WriteInt8(pid);
			}

			return std::move(writer);
		}
	};

	// Server <-> Client
	class MessagePacket final : public Packet {
	public:
		uint8_t flag;
		Utils::MCString message;

		MessagePacket() : MessagePacket(0, std::string()) {}
		MessagePacket(uint8_t flag, Utils::MCString message) :
			Packet(Opcodes::kMessage, kMessageSize),
			flag(flag),
			message(message)
		{}

		virtual void Deserialize(Utils::BufferStream& reader) override
		{
			// Skip opcode because each packet knows its opcode
			reader.Skip(sizeof(m_opcode));

			reader.ReadUInt8(flag);
			reader.ReadMCString(message);
		}

		virtual std::unique_ptr<Utils::BufferStream> Serialize() override
		{
			auto writer = std::make_unique<Utils::BufferStream>(m_packetSize);

			if (writer != nullptr) {
				writer->WriteUInt8(m_opcode);
				writer->WriteUInt8(flag);
				writer->WriteMCString(message);
			}

			return std::move(writer);
		}
	};

	// Server -> Client
	class ServerIdentificationPacket final : public Packet {
	public:
		uint8_t version;
		Utils::MCString name;
		Utils::MCString motd;
		uint8_t userType;

		ServerIdentificationPacket() : ServerIdentificationPacket(0, std::string(), std::string(), 0) {}
		ServerIdentificationPacket(uint8_t version, Utils::MCString name, Utils::MCString motd, uint8_t userType) :
			Packet(Opcodes::kServerIdentification, kServerIdentificationSize),
			version(version),
			name(name),
			motd(motd),
			userType(userType)
		{}

		virtual void Deserialize(Utils::BufferStream& reader) override
		{
		}

		virtual std::unique_ptr<Utils::BufferStream> Serialize() override
		{
			auto writer = std::make_unique<Utils::BufferStream>(m_packetSize);

			if (writer != nullptr) {
				writer->WriteUInt8(m_opcode);
				writer->WriteUInt8(version);
				writer->WriteMCString(name);
				writer->WriteMCString(motd);
				writer->WriteUInt8(userType);
			}

			return std::move(writer);
		}
	};

	// Server -> Client
	class LevelInitializePacket final : public Packet {
	public:

		LevelInitializePacket() : Packet(Opcodes::kLevelInitialize, kLevelInitializeSize) {}

			virtual void Deserialize(Utils::BufferStream& reader) override
		{
		}

		virtual std::unique_ptr<Utils::BufferStream> Serialize() override
		{
			auto writer = std::make_unique<Utils::BufferStream>(m_packetSize);

			if (writer != nullptr) {
				writer->WriteUInt8(m_opcode);
			}

			return std::move(writer);
		}
	};

	// Server -> Client
	class LevelDataChunkPacket final : public Packet {
	public:
		uint16_t chunkLength;
		uint8_t chunkData[1024];
		uint8_t percent;

		LevelDataChunkPacket() : LevelDataChunkPacket(0, 0, 0) {}
		LevelDataChunkPacket(uint16_t chunkLength, uint8_t chunkData[1024], uint8_t percent) :
			Packet(Opcodes::kLevelDataChunk, kLevelDataChunkSize),
			chunkLength(chunkLength),
			percent(percent)
		{}

		virtual void Deserialize(Utils::BufferStream& reader) override
		{
		}

		virtual std::unique_ptr<Utils::BufferStream> Serialize() override
		{
			auto writer = std::make_unique<Utils::BufferStream>(m_packetSize);

			if (writer != nullptr) {
				writer->WriteUInt8(m_opcode);
				writer->WriteUInt16(htons(chunkLength));
				writer->WriteArray1024(chunkData);
				writer->WriteUInt8(percent);
			}

			return std::move(writer);
		}
	};

	// Server -> Client
	class LevelFinalizePacket final : public Packet {
	public:
		int16_t x;
		int16_t y;
		int16_t z;

		LevelFinalizePacket() : LevelFinalizePacket(0, 0, 0) {}
		LevelFinalizePacket(int16_t x, int16_t y, int16_t z) :
			Packet(Opcodes::kLevelFinalize, kLevelFinalizeSize),
			x(x),
			y(y),
			z(z)
		{}

		virtual void Deserialize(Utils::BufferStream& reader) override
		{
		}

		virtual std::unique_ptr<Utils::BufferStream> Serialize() override
		{
			auto writer = std::make_unique<Utils::BufferStream>(m_packetSize);

			if (writer != nullptr) {
				writer->WriteUInt8(m_opcode);
				writer->WriteInt16(htons(x));
				writer->WriteInt16(htons(y));
				writer->WriteInt16(htons(z));
			}

			return std::move(writer);
		}
	};

	// Server -> Client
	class SetBlock2Packet final : public Packet {
	public:
		int16_t x;
		int16_t y;
		int16_t z;
		uint8_t type;

		SetBlock2Packet() : SetBlock2Packet(0, 0, 0, 0) {}
		SetBlock2Packet(int16_t x, int16_t y, int16_t z, uint8_t type) :
			Packet(Opcodes::kSetBlock2, kSetBlock2Size),
			x(x),
			y(y),
			z(z),
			type(type)
		{}

		virtual void Deserialize(Utils::BufferStream& reader) override
		{
		}

		virtual std::unique_ptr<Utils::BufferStream> Serialize() override
		{
			auto writer = std::make_unique<Utils::BufferStream>(m_packetSize);

			if (writer != nullptr) {
				writer->WriteUInt8(m_opcode);
				writer->WriteInt16(htons(x));
				writer->WriteInt16(htons(y));
				writer->WriteInt16(htons(z));
				writer->WriteUInt8(type);
			}

			return std::move(writer);
		}
	};

	// Server -> Client
	class SpawnPlayerPacket final : public Packet {
	public:
		int8_t pid;
		Utils::MCString name;
		int16_t x;
		int16_t y;
		int16_t z;
		uint8_t yaw;
		uint8_t pitch;

		SpawnPlayerPacket() : SpawnPlayerPacket(0, std::string(), 0, 0, 0, 0, 0) {}
		SpawnPlayerPacket(int8_t pid, Utils::MCString name, int16_t x, int16_t y, int16_t z, uint8_t yaw, uint8_t pitch) :
			Packet(Opcodes::kSpawnPlayer, kSpawnPlayerSize),
			pid(pid),
			name(name),
			x(x),
			y(y),
			z(z),
			yaw(yaw),
			pitch(pitch)
		{}

		virtual void Deserialize(Utils::BufferStream& reader) override
		{
		}

		virtual std::unique_ptr<Utils::BufferStream> Serialize() override
		{
			auto writer = std::make_unique<Utils::BufferStream>(m_packetSize);

			if (writer != nullptr) {
				writer->WriteUInt8(m_opcode);
				writer->WriteInt8(pid);
				writer->WriteMCString(name);
				writer->WriteInt16(htons(x));
				writer->WriteInt16(htons(y));
				writer->WriteInt16(htons(z));
				writer->WriteUInt8(yaw);
				writer->WriteUInt8(pitch);
			}

			return std::move(writer);
		}
	};

	// Server -> Client
	class UserTypePacket final : public Packet {
	public:
		uint8_t type;

		UserTypePacket() : UserTypePacket(0) {}
		UserTypePacket(uint8_t type) :
			Packet(Opcodes::kUserType, kUserTypeSize),
			type(type)
		{}

		virtual void Deserialize(Utils::BufferStream& reader) override
		{
		}

		virtual std::unique_ptr<Utils::BufferStream> Serialize() override
		{
			auto writer = std::make_unique<Utils::BufferStream>(m_packetSize);

			if (writer != nullptr) {
				writer->WriteUInt8(m_opcode);
				writer->WriteUInt8(type);
			}

			return std::move(writer);
		}
	};

	// Server -> Client
	class DisconnectPlayerPacket final : public Packet {
	public:
		Utils::MCString reason;

		DisconnectPlayerPacket() : DisconnectPlayerPacket(std::string()) {}
		DisconnectPlayerPacket(Utils::MCString reason) :
			Packet(Opcodes::kDisconnectPlayer, kDisconnectPlayerSize),
			reason(reason)
		{}

		virtual void Deserialize(Utils::BufferStream& reader) override
		{
		}

		virtual std::unique_ptr<Utils::BufferStream> Serialize() override
		{
			auto writer = std::make_unique<Utils::BufferStream>(m_packetSize);

			if (writer != nullptr) {
				writer->WriteUInt8(m_opcode);
				writer->WriteMCString(reason);
			}

			return std::move(writer);
		}
	};

	static std::shared_ptr<Packet> MakeSetBlockPacket(
		int16_t x,
		int16_t y,
		int16_t z,
		uint8_t mode,
		uint8_t type
	);

	static std::shared_ptr<Packet> MakePositionOrientationPacket(
		int8_t pid,
		int16_t x,
		int16_t y,
		int16_t z,
		uint8_t yaw,
		uint8_t pitch
	);

	static std::shared_ptr<Packet> MakeOrientationPacket(
		int8_t pid,
		uint8_t yaw,
		uint8_t pitch
	);

	static std::shared_ptr<Packet> MakeDespawnPacket(
		int8_t pid
	);

	static std::shared_ptr<Packet> MakeMessagePacket(
		uint8_t flag,
		Utils::MCString message
	);

	static std::shared_ptr<Packet> MakeServerIdentificationPacket(
		uint8_t version,
		Utils::MCString name,
		Utils::MCString motd,
		uint8_t userType
	);

	static std::shared_ptr<Packet> MakeLevelInitializePacket(
	);

	static std::shared_ptr<Packet> MakeLevelDataChunkPacket(
		uint16_t chunkLength,
		uint8_t chunkData[1024],
		uint8_t percent
	);

	static std::shared_ptr<Packet> MakeLevelFinalizePacket(
		int16_t x,
		int16_t y,
		int16_t z
	);

	static std::shared_ptr<Packet> MakeSetBlock2Packet(
		int16_t x,
		int16_t y,
		int16_t z,
		uint8_t type
	);

	static std::shared_ptr<Packet> MakeSpawnPlayerPacket(
		int8_t pid,
		Utils::MCString name,
		int16_t x,
		int16_t y,
		int16_t z,
		uint8_t yaw,
		uint8_t pitch
	);

	static std::shared_ptr<Packet> MakeUserTypePacket(
		uint8_t type
	);

	static std::shared_ptr<Packet> MakeDisconnectPlayerPacket(
		Utils::MCString reason
	);
	/* END AUTOGENERATED CODE SECTION */

	std::function<void(std::shared_ptr<Net::Client>, const AuthenticationPacket&)> onAuthenticationCallback;
	std::function<void(std::shared_ptr<Net::Client>, const SetBlockPacket&)> onSetBlockCallback;
	std::function<void(std::shared_ptr<Net::Client>, const PositionOrientationPacket&)> onPositionOrientationCallback;
	std::function<void(std::shared_ptr<Net::Client>, const MessagePacket&)> onMessageCallback;

	ClassicProtocol();

	virtual ~ClassicProtocol() {}

	ClassicProtocol(const ClassicProtocol&) = delete;
	ClassicProtocol& operator=(const ClassicProtocol&) = delete;

	virtual size_t GetPacketSize(uint8_t opcode) const override;
	virtual bool HandleOpcode(uint8_t opcode, std::shared_ptr<Net::Client> client, Utils::BufferStream& reader) const override;
private:
	std::map<Opcodes, OpcodeHandler> m_defaultPacketHandlers;

	void AuthenticationOpcodeHandler(std::shared_ptr<Net::Client> client, Utils::BufferStream& reader);
	void SetBlockOpcodeHandler(std::shared_ptr<Net::Client> client, Utils::BufferStream& reader);
	void PositionOrientationOpcodeHandler(std::shared_ptr<Net::Client> client, Utils::BufferStream& reader);
	void MessageOpcodeHandler(std::shared_ptr<Net::Client> client, Utils::BufferStream& reader);
};
} // namespace Net

#endif // CLASSICPROTOCOL_H_
